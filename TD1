pragma solidity ^0.4.0;

contract TP1_Vote {
// The vote takes place during a General Assembly, where every electors will vote yes or no for each propositions.

    // Variables
    address public administrator; 
    uint maxNumberPropositions; //The maximum number of propositions 
    mapping(address => uint256) politicalTrack;
    mapping(address => bool) hasVoted;
    mapping(address => uint) votes;
    mapping(uint => uint256) nbVote;
    uint yes1;
    uint yes2;
    uint no1;
    uint no2;
    uint proposition1;
    uint proposition2;
    
    function TP1_Vote(uint _maxNumberPropositions) {
        // We can have the adress in hardcoded and after give the right to call the function at the admin
        address sender = 0x123; 
        administrator = sender;
        
        // We fixe the maximum number of propositions during an General Assembly to 2.
        maxNumberPropositions = 2;
        
        // On différencie entre la variable déclarée précédemment (maxNumberPropositions) et l'argument de la fonction (_maxNumberPropositions) 
        maxNumberPropositions = _maxNumberPropositions; 
    }

    // Give to the voter the right to vote. But he only be called by the administrator.
   function giveRightToVote(address voter) {
        if (msg.sender != administrator || hasVoted[voter])//If the voter voted or the administrator is not the person who called the function
        {
            return; //nothing happened
        }
        politicalTrack[voter] = 1; //Else, the voter can vote. He can have one political track.
    }

    // Give a single vote to proposition
    function vote(uint proposition, bool choice) {
        address sender = 0x123; 
        if (hasVoted[sender] || proposition >= maxNumberPropositions) // If the voter voted or the number of propositions = maximum number of propositions
        {
            return; //Nothing happened
        }
        if(proposition==1)
        {
            if(choice == true)
            {
                yes1++;
                proposition1 = proposition;
            }
            else
            {
                no1++;
            }
        }
        if(proposition==2)
        {
            if(choice == true)
            {
                yes2++;
                proposition2 = proposition;
            }
            else
            {
                no2++;
            }
        }
}

    function winningProposition() returns (uint winningProposition) {
        uint nbProposition = 0; // On initialise le nombre de proposition à zéro
        while (nbProposition < maxNumberPropositions) {
            if (yes1 > no1) {
                winningProposition = proposition1;
            }
            if (yes2 > no2) {
                winningProposition = proposition2;
            }
            ++nbProposition; //On incrémente de un le compteur du nombre de proposition afin de parcourir 
        }
    }
}
